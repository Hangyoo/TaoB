import pandas as pd
import warnings
import numpy as np
import geatpy as ea

"""
最小化目标双目标优化问题
max f1 
min f2  
"""

class MyProblem(ea.Problem):  # 继承Problem父类
    def __init__(self, M=2):
        name = 'MyProblem'  # 初始化name（函数名称，可以随意设置）
        Dim = 33  # 初始化Dim（决策变量维数）
        maxormins = [-1,1]  # 初始化maxormins（目标最小最大化标记列表，1：最小化该目标；-1：最大化该目标）
        varTypes = [0] * Dim  # 初始化varTypes（决策变量的类型，0：实数；1：整数）
        lb = [80,5,20,80,5,20,80,5,20,80,5,20,80,5,20,80,5,20,80,5,20,80,5,20,80,5,20,80,5,20,80,5,20]   # 决策变量下界
        ub = [1500,400,500,1500,400,500,1500,400,500,1500,400,500,1500,400,500,1500,400,500,1500,400,500,1500,400,500,1500,400,500,1500,400,500,1500,400,500]  # 决策变量上界
        lbin = [1] * Dim  # 决策变量下边界（0表示不包含该变量的下边界，1表示包含）
        ubin = [1] * Dim  # 决策变量上边界（0表示不包含该变量的上边界，1表示包含）
        # 调用父类构造方法完成实例化
        ea.Problem.__init__(self, name, M, maxormins, Dim, varTypes, lb, ub, lbin, ubin)

    def aimFunc(self, pop):  # 目标函数
        Vars = pop.Phen  # 得到决策变量矩阵
        Vars = np.array(Vars, dtype=float)
        sumlist = Vars.sum(axis=1)
        # 归一化
        for i in range(Vars.shape[1]):
            Vars[i, :] = 7639.20 * Vars[i, :] / sumlist[i]

        x1,x2,x3,x4,x5 = Vars[:, [0]],Vars[:, [1]],Vars[:, [2]],Vars[:, [3]],Vars[:, [4]]
        x6,x7,x8,x9,x10 = Vars[:, [5]],Vars[:, [6]],Vars[:, [7]],Vars[:, [8]],Vars[:, [9]]
        x11,x12,x13,x14,x15 = Vars[:, [10]],Vars[:, [11]],Vars[:, [12]],Vars[:, [13]],Vars[:, [14]]
        x16,x17,x18,x19,x20 = Vars[:, [15]],Vars[:, [16]],Vars[:, [17]],Vars[:, [18]],Vars[:, [19]]
        x21,x22,x23,x24,x25 = Vars[:, [20]],Vars[:, [21]],Vars[:, [22]],Vars[:, [23]],Vars[:, [24]]
        x26,x27,x28,x29,x30 = Vars[:, [25]],Vars[:, [26]],Vars[:, [27]],Vars[:, [28]],Vars[:, [29]]
        x31,x32,x33 = Vars[:, [30]],Vars[:, [31]],Vars[:, [32]]


        f1 = 0.64*x1+7.73*x2+1.80*x3+0.59*x4+7.73*x5+15.20*x6+0.57*x7+7.05*x8+1.68*x9+0.66*x10+5.59*x11+1.98*x12+0.61*x13+5.73*x14+\
        1.43*x15+0.61*x16+6.25*x17+0.86*x18+0.38*x19+5.99*x20+0.55*x21+0.51*x22+6.47*x23+1.03*x24+0.50*x25+6.63*x26+0.86*x27+0.53*x28+\
        6.26*x29+1.52*x30+0.60*x31+4.61*x32+2.10*x33

        f2 = 0.01*x1+0.02*x2+0.01*x3+0.03*x4+0.02*x5+0.01*x6+0.03*x7+0.02*x8+0.01*x9+0.01*x10+0.02*x11+0.01*x12+0.01*x13+0.02*x14+\
             0.01*x15+0.01*x16+0.02*x17+0.01*x18+0.02*x19+0.02*x20+0.01*x21+0.03*x22+0.02*x23+0.01*x24+0.01*x25+0.02*x26+0.01*x27+\
             0.02*x28+0.02*x29+0.01*x30+0.01*x31+0.02*x32+0.01*x33

        pop.ObjV = np.hstack([f1, f2])  # 把求得的目标函数值赋值给种群pop的ObjV

        c1 = 0.01*x1+0.02*x2+0.01*x3+0.03*x4+0.02*x5+0.01*x6+0.03*x7+0.02*x8+0.01*x9+0.01*x10+0.02*x11+0.01*x12+0.01*x13+0.02*x14+\
             0.01*x15+0.01*x16+0.02*x17+0.01*x18+0.02*x19+0.02*x20+0.01*x21+0.03*x22+0.02*x23+0.01*x24+0.01*x25+0.02*x26+0.01*x27+\
             0.02*x28+0.02*x29+0.01*x30+0.01*x31+0.02*x32+0.01*x33<114.3

        c2 = 4062.33 - (0.64*x1+0.59*x4+0.57*x7+0.66*x10+0.61*x13+0.61*x16+0.38*x19+0.51*x22+0.50*x25+0.53*x28+0.60*x31)

        c3 = 3515.17 - (7.73*x2+7.73*x5+7.05*x8+5.59*x11+5.73*x14+6.25*x17+5.99*x20+6.47*x23+6.63*x26+6.26*x29+ 4.61*x32)

        c4 = 1330.12 - (1.80*x3+15.20*x6+1.68*x9+1.98*x12+1.43*x15+0.86*x18+0.55*x21+1.03*x24+0.86*x27+1.52*x30+2.10*x33)

        c5 = x1+x2+x3+x4+x5+x6+x7+x8+x9+x10+x11+x12+x13+x14+x15+x6+x17+x18+x19+x20+x21+x22+x23+x24+x25+x26+x27+x28+x29+x30+x31+x32+x33-7639.20

        c6 = 7639.20 - (x1+x2+x3+x4+x5+x6+x7+x8+x9+x10+x11+x12+x13+x14+x15+x16+x17+x18+x19+x20+x21+x22+x23+x24+x25+x26+x27+x28+x29+x30+x31+x32+x33)

        pop.CV = np.hstack([c1,c2,c3,c4,c5,c6])
